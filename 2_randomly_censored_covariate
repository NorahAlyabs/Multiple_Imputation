#################################################################### 
#                                                                  #
#                  Simulation for P-AFT model                      #
#                 with 2 randomly censored covariates              #
#                                                                  #
####################################################################

#required packages for the simulation.
library(survival)
library(mice)
library(aftgee)
library(copula)

#The survival package is required for fitting the AFT model and the Cox PH model
#The mice package is used to impute the missing values by the predictive mean matching (PMM) method.
#The aftgee package is used to fit semi-parametric AFT model
#The copula package is required to generate corroleted covariates

#'Define variables:
#'
#' @param n is the sample size n = 100, 300
#' @param cr is the censoring proportion for X, Ti, we used cr= 20%, and 40%
#' @param X1, X2 covariates subjected to LOD, X ~ Weibul(1,1/3)
#' @param Z fully observed covariate , Z ~ Normal(0,1)
#' @param V1, V2 missing indicators for X1 , X2
#' @param Ti Failure time, log(Ti) = -2.5 + X1 - X2 +  Z + e
#' @param e error term e ~ Normal(0,1)
#' @param cen is censoring time for X1, X2
#' @param Y is the observed failure time Y=min(T, ceny)
#' @param Delta missing indicator for Ti

#' 1- Generating Data:

gen.data2.C2 <- function (n, cr, rho) {
  if(rho == 0){X1 <- rweibull(n, 1, 1/3)
  X2 <- rweibull(n, 1, 1/3)
  Z <- rnorm(n)
  }else{
    copula1 <- rCopula (n, claytonCopula (iRho (claytonCopula ( dim = 3 ), rho), dim = 3))
    X1 <- qweibull(copula1[,1], 1, 1/3)
    X2 <- qweibull(copula1[,2], 1, 1/3)
    Z <- qnorm(copula1[,3], 0, 1)}
  if (!(cr %in% c(0, .2, .4)))    stop("Undefinded censoring rate")
  if (cr == 0)     cen <- Inf
  if (cr == 0.2)   {cen <- rweibull(n, 1, 1.33)} 
  if (cr == 0.4)   {cen <- rweibull(n, 0.8, 0.6)}
  cen1 <- rweibull(n, 0.6, 0.6)
  #sum((X1 <= cen))
  #summary(cen)
  V1 <- 1 * (X1 <= cen)   # 1 => observed, 0 => censored
  V2 <- 1 * (X2 <= cen)   # 1 => observed, 0 => censored
  Ti <- exp(-2.5 +  X1 - 1 * X2 + 1 * Z + rnorm(n, 0, 1))
  # sum(Ti <= cen)
  D <- 1 *(Ti <= cen1)     # 1 => observed, 0 => censored
  return(data.frame( Y = pmin(Ti, cen1), Delta = D, V1 = V1, X1 = pmin(X1, cen), V2 = V2, X2 = pmin(X2, cen), Z = Z ))
}
summary(replicate(100,sum( gen.data2.C2(100,.2,0.3)$Delta)))



#' Methods:
#' 
# 2.1 Multiple Imputation with predictive density function:
oneImp2 <- function(dat, fit1) {
  datB <- dat[sample(1:nrow(dat), nrow(dat), TRUE), ]
  rownames(datB) <- NULL
  fitX1 <- coxph(Surv(X1, V1) ~ X2 + Z, data = datB)
  fitX2 <- coxph(Surv(X2, V2) ~ X1 + Z, data = datB)
  xi1 <- sort(unique(datB$X1))
  xi2 <- sort(unique(datB$X2))
  impute1 <- function(x1, x2, y, z, d) {
    XB <- c(coef(fit1) %*% matrix(c(rep(1,length(xi1)),xi1, rep(x2,length(xi1)), rep(z,length(xi1))), nrow=4, byrow = TRUE))
    if (d == 1)  pii1 <- pii2 <- dlnorm(y, XB, fit1$scale )
    if (d == 0) {pii1 <- 1- plnorm(log(y) , XB, fit1$scale )} & {pii2 <- -plnorm(log(y) , XB, fit1$scale )}
    Sx <-  exp(-basehaz(fitX1, centered = FALSE)$hazard * exp( sum(coef(fitX1) * c(x2, z))))
    px <- pii1 * Sx + coef(fit1)["X1"] / (fit1$scale^2) * rev(cumsum(rev(pii2 * (log(y)-XB) * Sx * diff(c(0, xi1)))))
    Px <- approxfun(c(0, xi1[xi1 >= x1]), c(1, px[xi1 >= x1] / px[findInterval(x1, xi1)]), yleft = 1 , yright = 0)
    u <- runif(1)
    uniroot(f = function(x)  Px(x) - u, lower = 0,  upper = 1 + max(xi1) )$root
  }
  impute2 <- function(x1, x2, y, z, d) {
    XB <- c(coef(fit1) %*% matrix(c(rep(1,length(xi2)), rep(x1,length(xi2)), xi2, rep(z,length(xi2))), nrow=4, byrow = TRUE))
    if (d == 1)  pii1 <- pii2 <- dlnorm(y, XB, fit1$scale )
    if (d == 0) {pii1 <- 1- plnorm(y , XB, fit1$scale )} & {pii2 <- -plnorm(y , XB, fit1$scale )}
    Sx <-  exp(-basehaz(fitX2, centered = FALSE)$hazard * exp( sum( coef( fitX2 ) * c(x1, z))))
    px <- pii1 * Sx +  coef(fit1)["X2"]/(fit1$scale^2) * rev(cumsum(rev( pii2 *(log(y)-XB) * Sx * diff(c(0, xi2)))))
    Px <- approxfun(c(0, xi2[xi2 >= x2]), c(1, px[xi2 >= x2] / px[findInterval(x2, xi2)]), yleft = 1 , yright = 0)
    u <- runif(1)
    uniroot(f = function(x)  Px(x) - u, lower = 0,  upper = 1 + max(xi2))$root
  }
  datB$imp1[datB$V1 == 0] <- with(subset(datB, V1 == 0), mapply(FUN = impute1, X1, X2, Y, Z, Delta))
  datB$imp1[datB$V1 == 1] <- datB$X1[datB$V1 == 1]
  datB$imp2[datB$V2 == 0] <- with(subset(datB, V2 == 0), mapply(FUN = impute2, X1, X2, Y, Z, Delta))
  datB$imp2[datB$V2 == 1] <- datB$X2[datB$V2 == 1]
  fit3 <- survreg(Surv(Y, Delta) ~ unlist(imp1) +  unlist(imp2) + Z, data = datB, dist= "lognormal"  )
  list(PE1 = coef(fit3)[2], PE2 = coef(fit3)[3], PE3 = coef(fit3)[4], SE1 = vcov(fit3)[2,2],  SE2 = vcov(fit3)[3,3], SE3 = vcov(fit3)[4,4])
}

#2.2 MIAFT: Multple imputation with (aftsrr)
oneImpaft <- function(dat = data){
  datB <- dat[sample(1:nrow(dat), nrow(dat), TRUE),]     #sample with replacement
  rownames(datB) <- NULL     #re-do ID
  CCA1 <- aftsrr(Surv(X1, V1) ~ Z , data = datB,  eqType = "is", B = 3 ,
                 se = "ISMB"  ,control = aftgee.control(maxiter=30, trace = FALSE))
  CCA2 <- aftsrr(Surv(X2, V2) ~ Z , data = datB, eqType = "is", B = 3 ,
                 se = "ISMB"  ,control = aftgee.control(maxiter=30, trace = FALSE))
  # Step 4. Generate Xmi for those with V i = 0 from the estimated distribution obtained from Step 2.
  datB$X1i <- datB$X1 ; datB$X2i <- datB$X2
  datB$X1i[datB$V1 == 0] <- exp(with(datB[datB$V1 ==0,], coef(CCA1)[1] * Z ))
  datB$X2i[datB$V2 == 0] <- exp(with(datB[datB$V2 ==0,], coef(CCA2)[1] * Z ))
  # Step Fit a parametric AFT model to the original data for Yi given Xoi and the imputed Xmi's
  fit <- survreg(Surv(Y, Delta) ~ X1i + X2i + Z, data = datB,  dist= "lognormal" )
  c(coef(fit)[2:4], diag(vcov(fit))[2:4])
}
# 3- Do function:

do2 <- function(n, cr, rho, M = 10) {
  data <- gen.data2.C2(n, cr, rho)
  ##CC:
  fit1 <- survreg(Surv(Y, Delta) ~ X1 + X2 + Z, data = data, subset = V1 * V2 > 0, dist= "lognormal" )
  ##Sub:
  dat1 <- data
  dat1$X1[dat1$V1 == 0] <- mean(data$X1[data$V1==1])
  dat1$X2[dat1$V2 == 0] <- mean(data$X2[data$V2==1])
  sub1 <- survreg(Surv(Y, Delta) ~ X1 + X2 + Z , data = dat1 , dist = "lognormal")
  Sub1 <- c(coef(sub1)[2:4], sqrt(diag(vcov(sub1))[2:4]))
  ##MDI
  MDI1 <- survreg(Surv(Y, Delta) ~ I(X1*V1) + I(X2*V2) + Z + I(1-V1)+ I(1-V2), data = data, dist= "lognormal" )
  ## MI:
  imps <- replicate(M, unlist(oneImp2(data, fit1)) )
  #MIAFT:
  MIAFT1 <- replicate(M, (oneImpaft(data)))
  MIAFT <- rowMeans(MIAFT1, na.rm = T)
  MIAFT[4:6] <- sqrt(rowMeans(MIAFT1[4:6, ]^2, na.rm = T) + (1+1/M) *
                     apply(MIAFT1[1:3, ], 1, sd))
  ## PMM:
  Data1 <- data
  Data1$X1[data$V1 == 0] <- Data1$X2[data$V2 == 0] <- NA
  #Split the data set into 2 subsets based on: observed Ti / censored Ti:
  data1 <- Data1[data$Delta==1,]
  data0 <- Data1[data$Delta==0,]
  predictormat <- 1 - diag(1, ncol(Data1))
  predictormat[,c(2,3,5)] <- 0
  #Impute each subset seperatly using (Y, X1, X2, Z)
  Imp_delta_1 <- mice(data1, meth=c("","","","pmm","","pmm",""), seed=2022,
                      predictorMatrix=predictormat, remove_collinear = T, printFlag = FALSE)
  Imp_delta_0 <- mice(data0, meth=c("","","","pmm","","pmm",""), seed=2022,
                      predictorMatrix=predictormat, remove_collinear = T, printFlag = FALSE)
  # fit AFT model after combining the imputed Data1_delta_1 and Data1_delta_0
  imp <- mice:::rbind.mids(Imp_delta_1, Imp_delta_0)
  PMM <- mice::pool(with(imp, survreg(Surv(Y, Delta)  ~ X1 + X2 + Z,
                                      dist ="lognormal",control = survreg.control(maxiter=31))))
   
  Results <- c( coef(fit1)[2:4], diag(vcov(fit1))[2:4], Sub1,
     coef(MDI1)[2:4], diag(vcov(MDI1))[2:4],
     mean(imps[1, ]), mean(imps[2, ]), mean(imps[3, ]),
     mean(imps[4, ]) + (1 + 1 / M) * var(imps[1, ]),
     mean(imps[5, ]) + (1 + 1 / M) * var(imps[2, ]),
     mean(imps[6, ]) + (1 + 1 / M) * var(imps[3, ]),
     MIAFT, summary(PMM)[2:4,1], summary(PMM)[2:4, 2]^2 )
  Resultsm <- matrix(Results,ncol = 6, nrow = 6, byrow = T)
  rownames(Resultsm) <- c("CC", "sub", "MDI", "MI", "MIAFT", "PMM")
  colnames(Resultsm) <- c("b1", "b2", "b3", "V(b1)", "V(b2)", "V(b3)")
  Resultsm
}
set.seed(123)
do2(200,.2,0)

             b1         b2       b3     V(b1)     V(b2)       V(b3)
CC    0.5380690 -1.2393196 1.064762 0.2035304 0.1449920 0.009494903
sub   0.5957543 -1.2581419 1.078549 0.4307997 0.3626653 0.084754533
MDI   0.5284694 -1.1859810 1.085627 0.1834850 0.1309842 0.007093613
MI    0.8887740 -1.1600533 1.002150 0.2062808 0.1830120 0.011985088
MIAFT 0.7546072 -0.6454277 1.065941 0.5270193 0.5348060 0.365511232
PMM   0.4982395 -1.0823088 1.077948 0.1964919 0.1267354 0.007314905


#################################################################### 
#                                                                  #
#                  Simulation for semi-p AFT model                 #
#              with 2 randomly censored covariates                 #
#                                                                  #
####################################################################

# 1. Generating data:
gen.data2.C2 <- function (n, cr, rho) {
  if(rho == 0){X1 <- rweibull(n, 1, 1/3)
  X2 <- rweibull(n, 1, 1/3)
 }else{
    copula1 <- rCopula (n, claytonCopula ( iRho (claytonCopula ( ), rho)))
    X1 <- qweibull(copula1[,1], 1, 1/3)
    X2 <- qweibull(copula1[,2], 1, 1/3)
 }
  Z <- rnorm(n)
  if (!(cr %in% c(0, .2, .4)))    stop("Undefinded censoring rate")
  if (cr == 0)     cen <- Inf
  if (cr == 0.2)   {cen <- rweibull(n, 1, 1.33)} 
  if (cr == 0.4)   {cen <- rweibull(n, 0.8, 0.6)} 
 # cen1 <- rweibull(n, 4, 5)
  V1 <- 1 * (X1 <= cen)   # 1 => observed, 0 => censored
  V2 <- 1 * (X2 <= cen)   # 1 => observed, 0 => censored
  Ti <- exp(-2.5 + X1 + X2 + Z + rnorm(n, 0, 1))
  D <- 1 *(Ti <= cen)     # 1 => observed, 0 => censored
  return(data.frame( Y = pmin(Ti, cen), Delta = D, V1 = V1, X1 = pmin(X1, cen), V2 = V2, X2 = pmin(X2, cen), Z = Z ))
} 

#2. Methods:
#2.2 Multiple imputation using semi-parametric AFT model:

oneImpaftsrr <- function(dat = data){
    datB <- dat[sample(1:nrow(dat), nrow(dat), TRUE),]     #sample with replacement
    rownames(datB) <- NULL     #re-do ID
    # Fit a semiparametric AFT model to the sampled data for Xmi given Xoi, 
    CCA1 <- aftsrr(Surv(X1, V1) ~ Z , data = datB,  eqType = "is", B = 3 ,
                   se = "ISMB"  ,control = aftgee.control(maxiter=30, trace = FALSE))
    CCA2 <- aftsrr(Surv(X2, V2) ~ Z , data = datB, eqType = "is", B = 3 ,
                   se = "ISMB"  ,control = aftgee.control(maxiter=30, trace = FALSE))
    # Step 4. Generate Xmi for those with V i = 0 from the estimated distribution obtained from Step 2.
    datB$X1i <- datB$X1 ; datB$X2i <- datB$X2
    datB$X1i[datB$V1 == 0] <- exp(with(datB[datB$V1 ==0,], coef(CCA1)[1] * Z ))
    datB$X2i[datB$V2 == 0] <- exp(with(datB[datB$V2 ==0,], coef(CCA2)[1] * Z ))
    # Step Fit a semiparametric AFT model to the original data for Yi given Xoi and the imputed Xmi's
    fit <- aftsrr(Surv(Y, Delta) ~ X1i + X2i + Z, data = datB, eqType = "is", B = 3 ,
                  se = "ISMB"  ,control = aftgee.control(maxiter=30, trace = FALSE))
    c(coef(fit)[1:3], diag(vcov(fit)$ISMB)[1:3])
  }
  
One.Simulation.SAFT.2X <- function(n, cr, rho, M=10) { 
  # Generating data:
  data <- gen.data2.C2(n, cr, rho)
  # M1-  CC: Complete case
  CCA <- aftsrr(Surv(Y, Delta) ~ X1 + X2 + Z, data = data, subset = V1 * V2 > 0, eqType = "is", B = 3 ,
                se = "ISMB"  ,control = aftgee.control(maxiter=30, trace = FALSE))
  CC1 <- c(coef(CCA), diag(vcov(CCA)$ISMB))
    
  # M2- Subtitution with the mean:
  dat1 <- data
  dat1$X1[dat1$V1 == 0] <- mean(data$X1[data$V1==1])
  dat1$X2[dat1$V2 == 0] <- mean(data$X2[data$V2==1])
  sub1 <- aftsrr(Surv(Y, Delta) ~ X1 + X2 + Z, data = dat1, eqType = "is", B = 3 ,
                        se = "ISMB"  ,control = aftgee.control(maxiter=30, trace = FALSE))
  Sub1 <- c(coef(sub1), diag(vcov(sub1)$ISMB))
  
  # M3- Missing indicator approach (MDI) :
  data2 <- data
  data2$X1V <- with(data2, X1 * V1) ; data2$X2V <- with(data2, X2 * V2)
  data2$V1V <- with(data2, 1 - V1  ); data2$V2V <- with(data2, 1 - V2)
  MDI <- aftsrr(Surv(Y, Delta) ~ X1V + X2V + Z + V1V + V2V, data = data2,
                eqType = "is", B = 3 , se = "ISMB"  ,control = aftgee.control(maxiter=30, trace = FALSE))
  MDI1 <- c(coef(MDI)[1:3], diag(vcov(MDI)$ISMB)[1:3])  
 
  ## M4. Multiple Imputation:
  # Step 4. Repeat Steps 1-3 a large number of B times.
  MIAFT <- replicate(10, (oneImpaftsrr(data)))
  MIaft <- rowMeans(MIAFT, na.rm = T)
  MIaft[4:6] <- sqrt(rowMeans(MIAFT[4:6, ]^2, na.rm = T) + (1+1/M) *
                     apply(MIAFT[1:3, ], 1, sd))
  Results <- c(CC1, Sub1, MDI1, MIaft)
  Resultsm <- matrix(Results,ncol = 6, nrow = 4, byrow = T)
  rownames(Resultsm) <- c("CC", "sub", "MDI", "MIAFT")
  colnames(Resultsm) <- c("b1", "b2", "b3", "V(b1)", "V(b2)", "V(b3)")
  Resultsm}
 
set.seed(123)
One.Simulation.SAFT.2X(200,.2,0)
             b1        b2        b3     V(b1)       V(b2)       V(b3)
CC    1.4039788 0.6795557 0.9926249 0.1236981 0.010734877 0.007261013
sub   1.1974908 0.7368714 0.9485431 0.1574042 0.205838946 0.006390655
MDI   1.2311396 0.7367839 0.9515663 0.1720474 0.005941846 0.011002155
MIAFT 0.5314276 0.3997726 0.9080222 0.5477174 0.428164201 0.340374655
 
